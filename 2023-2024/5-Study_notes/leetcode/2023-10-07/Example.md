# leetcode
## 二进制和位运算
![image](https://github.com/ZYJ-Group/Tanghy/assets/94824386/7e974948-e13f-4628-ba13-57aa01c46e19)  

### 笔记
**1. 负数怎么用二进制表达**  
十进制 | 二进制 | 十进制 | 二进制
--- | --- | --- | ---
-8 | 1000 | 0 | 0000
-7 | 1001 | 1 | 0001
-6 | 1010 | 2 | 0010
-5 | 1011 | 3 | 0011
-4 | 1100 | 4 | 0100
-3 | 1101 | 5 | 0101
-2 | 1110 | 6 | 0110
-1 | 1111 | 7 | 0111
1. 获取正数的二进制表示： 首先，将负数的绝对值表示为二进制数。  
2. 取反： 将正数的二进制表示中的每一位取反（0 变为 1，1 变为 0）。  
3. 加一： 对取反后的二进制数加一。


例如，考虑负数 -5：  
1. 正数 5 的二进制表示是 0101。  
2. 取反得到 1010。  
3. 加一得到 1011。  

**2. 常见的位运算（|、&、^、~、<<、>>、>>>）**   
1. 按位或（|）：  
作用： 对应位中只要有一个为1，结果就是1。  
示例： 1010 | 1100 = 1110  

2. 按位与（&）：  
作用： 对应位中只有都为1，结果才为1。  
示例： 1010 & 1100 = 1000  

3. 按位异或（^）：  
作用： 对应位中相同为0，不同为1。  
示例： 1010 ^ 1100 = 0110  

4. 按位取反（~）：  
作用： 对二进制数的每一位取反，0 变为1，1 变为0。  
示例： ~1010 = 0101  

5. 左移位（<<）：  
作用： 将一个数的二进制表示向左移动指定的位数，低位补0。  
示例： 1010 << 2 = 101000  

6. 右移位（>>）：  
作用： 将一个数的二进制表示向右移动指定的位数，高位使用原来的符号位填充（即正数补0，负数补1）。  
示例： 1010 >> 2 = 10  

7. 无符号右移位（>>>）：  
作用： 将一个数的二进制表示向右移动指定的位数，高位使用0填充，不考虑符号。  
示例： 1010 >>> 2 = 10

**3. 整数最小值的特殊性(取绝对值还是自己)**   
整数的最小值在计算机中通常是由系统表示的最小有符号整数，例如在32位系统上，整数最小值是-2,147,483,648。这个值的特殊性在于其绝对值没有对应的正整数表示，因为正整数的范围是0到2,147,483,647。因此，对整数最小值取绝对值会导致溢出错误。  


## 二进制和位运算
![image](https://github.com/ZYJ-Group/Tanghy/assets/94824386/54b9a02e-f2b5-4698-a0ac-3d0f534efe28)  

### 笔记
**1. 选择排序**  
1. 在未排序序列中找到最小元素。
2. 将其放置在已排序序列的末尾。
3. 从剩余未排序元素中继续执行步骤1和2，直到所有元素都被排序。

```
// 函数：交换数组中 i 和 j 位置的元素
void swap(int arr[], int i, int j) {
  int temp = arr[i];
  arr[i] = arr[j];
  arr[j] = temp;
}
// 选择排序
void selectionSort(int arr[], int size) {
  for (int i = 0; i < size - 1; i++) {
    int minIndex = i;
    for (int j = i + 1; j < size; j++) {
      if (arr[i] < arr[minIndex]) {
        minIndex = j;
      }
    }
    swap(arr, i, minIndex);
  }
}
```
**2. 冒泡排序**  
1. 从头开始，比较相邻的两个元素。
2. 如果顺序错误，则交换它们。
3. 重复步骤1和2，直到没有需要交换的元素。
4. 重复整个过程，每次都将最大的元素沉到序列的末尾。
```
// 冒泡排序
void bubbleSort(int arr[], int size) {
  for (int end = size - 1; end > 0; end--) {
    for (int i = 0; i < end; i++) {
      if (arr[i] > arr[i + 1]) {
        swap(arr, i, i + 1);
      }
    }
  }
}
```

**3. 插入排序**  
1. 从第一个元素开始，该元素可以认为已经被排序。
2. 取出下一个元素，在已经排序的元素序列中从后向前扫描。
3. 如果该元素（已排序）大于新元素，将该元素移到下一位置。
4. 重复步骤3，直到找到已排序的元素小于或等于新元素的位置。
5. 将新元素插入到找到的位置。
6. 重复步骤2到5，直到整个序列有序。
```
// 插入排序
void insertSort(int arr[], int size) {
  for (int i = 1; i < size; i++) {
    for (int j = i - 1; j >= 0 && arr[j] > arr[j + 1]; j--) {
      swap(arr, j, j + 1);
    }
  }
}
```
