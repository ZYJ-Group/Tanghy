# 北京洪水时序分析结果
- [代码](https://github.com/Axianlatiao/Test/blob/main/Daily/2023-08-21/%E6%B4%AA%E6%B0%B4%E5%89%8D%E5%90%8E.txt)
- 这段代码使用了Google Earth Engine的JavaScript API，旨在处理Sentinel-1合成孔径雷达（SAR）影像，以便在洪水事件前后检测和分析洪水区域。代码按照一系列步骤完成此目标。我们逐段解释代码：

1. **几何形状和时间范围设置：**
   - 代码开始通过地理坐标定义了研究区域的多边形几何形状。
   - 它使用变量`before_start`、`before_end`、`after_start`和`after_end`指定了“洪水前”和“洪水后”的影像日期范围。

2. **SAR影像集筛选：**
   - 代码根据多个条件对Sentinel-1影像集进行了筛选：仪器模式、极化方式、通过方向（上行）、分辨率和地理范围。
   - 它选择了特定的极化方式（VH或VV），并相应地对影像集进行了筛选。

3. **筛选洪水前后的影像：**
   - 代码通过使用之前定义的日期范围，对影像集进行筛选，以获取洪水前后的SAR影像。
   - 它将筛选后的影像集的大小打印到控制台。

4. **导出洪水后的影像：**
   - 代码遍历洪水后的影像集，并将每个影像分别导出到Google Drive。
   - 它为每个影像构建名称，并指定导出参数，如影像、描述、文件夹、分辨率和区域。

5. **影像镶嵌和平滑处理：**
   - 代码对洪水前后的影像集进行镶嵌，并将其剪裁为研究区域。
   - 它使用`focal_mean`函数和指定的平滑半径对两个影像应用了均值滤波，以减少噪声。

6. **计算影像差异和阈值处理：**
   - 代码计算了洪水后影像相对于洪水前影像的强度比（差异）。
   - 它应用阈值来创建二进制洪水范围掩膜。
   - 进一步通过应用像素连接分析来细化掩膜，以去除孤立像素。

7. **根据坡度过滤淹没区域：**
   - 代码计算了数字高程模型（DEM）的坡度，并使用它来过滤掉坡度大于5度的淹没区域。

8. **计算淹没面积：**
   - 代码通过将二进制掩膜与像元面积相乘，并对结果进行求和，计算出淹没的面积。
   - 最后，将计算结果从平方米转换为公顷。

9. **导出结果：**
   - 代码以栅格（TIFF）格式导出二进制洪水范围掩膜。
   - 还使用`reduceToVectors`将二进制掩膜转换为矢量格式（多边形），并以形状文件（SHP）格式导出。

总体而言，代码处理SAR影像，以便在洪水事件后检测和量化洪水区域。它执行一系列操作，包括影像筛选、镶嵌、阈值处理、坡度过滤和面积计算。最后，它导出了检测到的洪水区域的栅格和矢量表示。



- 北京市区地形图
![Beijing](https://github.com/Axianlatiao/Test/assets/94824386/bac01b2e-b732-488b-84ca-9a3767fd50cd)

- 北京洪水前图像
![Before_flood](https://github.com/Axianlatiao/Test/assets/94824386/b682ca8e-6ea9-4d04-ad7d-1ddc82dc83a5)

- 北京洪水后图像
![After_flood](https://github.com/Axianlatiao/Test/assets/94824386/76d362f2-d39d-43e0-b36c-872b18f19727)

- 可能的洪水影响区域
![Area_flood](https://github.com/Axianlatiao/Test/assets/94824386/1d9c13c5-0769-4cde-8f51-e1c8e43830fc)


## ps.尝试将图像逐个导出，但是图像并不完全。
- [代码](https://github.com/Axianlatiao/Test/blob/main/Daily/2023-08-21/%E5%AF%BC%E5%87%BA.txt)
